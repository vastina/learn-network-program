#ifndef _TASKPOOL_H_
#define _TASKPOOL_H_

#include <thread>
#include <future>
#include <functional>
#include <queue>
#include <vector>

#define VASTINA_CPP
#include "tools.h"
#include "loger.hpp"

enum importance{
        maintk=1,
        common,
        lowest 
    };

class Taskpool{
private:
    struct _maintk{
        std::vector<std::thread> workers;
        std::queue<std::function<void()>> tasks;
        std::mutex m1;
    } maintk_ ;

    struct _common{
        std::thread worker;
        std::packaged_task<void()> work;
        std::queue<std::function<void()>> tasks;
        std::mutex m2;
    } common_;

    struct _lowest{
        std::queue<std::function<void()>> tasks;
        std::mutex m3;
    } lowest_;

    struct stopcontrol{
        std::mutex stopmutex;
        bool stop;
    } controler ;
    
    
public:
    void start(size_t threads);
    template<typename F, typename...Args>
        void submittask(F&& f, Args&&... args, int level);
    void lastwork();
    void setstoped();
};

void Taskpool::start(size_t threads){
    {
    std::unique_lock<std::mutex> lk(controler.stopmutex);
    controler.stop = false;
    common_.work = std::packaged_task<void()>{[&]()->void{
        for(;;){
            if(common_.tasks.empty()) std::this_thread::sleep_for(std::chrono::milliseconds(100));
            std::function<void()> task;
            {
                std::unique_lock<std::mutex> lock(controler.stopmutex);
                if(controler.stop && common_.tasks.empty()) break;
                if(!common_.tasks.empty()){
                    task = std::move(common_.tasks.front());
                    common_.tasks.pop();
                } 
            }
            task();
        } 
    }};
    common_.worker = std::thread{ [this](){ common_.work(); } };
    }
    submittask([]{ vastina_log::logtest("taskpool init"); } , importance::lowest);
}

void Taskpool::lastwork() {
    {
        std::unique_lock<std::mutex> lock(tmutex);
        std::function<void()> task;
        while (!tasks.empty())
        {
            {
                task = std::move(tasks.front());
                tasks.pop();
            }
            task();
        }
    }
    //print("(commonfuture: {})\n",common._future.get());
};

template<typename F, typename...Args>
void Taskpool::submittask(F&& f, Args&&... args, int level) {
    std::function<decltype(f(args...))()> func 
        = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
    auto task_ptr = std::make_shared<std::packaged_task<decltype(f(args...))()>>(func);
    if(level == importance::lowest){
        {
            std::unique_lock<std::mutex> lock(tmutex);
            tasks.emplace(std::function<void()>( [task_ptr](){
                (*task_ptr)(); 
            }));
        }       
    }
    else if(level == importance::common){
        {
            std::unique_lock<std::mutex> lk(tmutex);
            tasks2.emplace(std::function<void()>( [task_ptr](){
                (*task_ptr)(); 
            }));
            //common.condition.notify_one();
        }
        if(common.worker.joinable()) common.worker.join();
    }
};

void Taskpool::setstoped(){
    {
        std::unique_lock<std::mutex> lk(tmutex);
        common_.stop = true;
    }
}

#endif